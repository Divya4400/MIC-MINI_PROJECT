/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Dec 14 2022 09:14:14 GMT+0000 (Coordinated Universal Time).
 */

define(['css!./styles/PNVisualizerWidget.css'], function () {
    'use strict';

    var WIDGET_CLASS = 'p-n-visualizer';

    function PNVisualizerWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug("ctor finished");
    }

   //defined structure and shape of place
    PNVisualizerWidget.prototype._initialize = function () {
        joint.shapes.pn.Place = joint.shapes.basic.Generic.define(
            'pn.Place',
            {
              size: { width: 70, height: 70 },
              attrr: {
                //for root
                ".root": {
                  r: 20,
                  fill: "#fffff",
                  stroke: "#00000",
                  transform: "translate(20, 20)",
                },

                //for label
                ".label": {
                  "text-anchor": "middle",
                  "ref-x": 0.7,
                  "ref-y": -20,
                  ref: ".root",
                  fill: "#00000",
                  "font-size": 18,
                },
                
                //for token
                ".tokens > circle": {
                  fill: "black",
                  r: 2,
                },

                ".tokens.alot > text": {
                  transform: "translate(25, 16)",
                  "text-anchor": "middle",
                  fill: "#00000",
                },

              },

            },

            {
              markup:
                '<g class="rotatable"><g class="scalable"><circle class="root"/><g class="tokens" /></g><text class="label"/></g>',
            }

          );
      
          joint.shapes.pn.PlaceView = joint.dia.ElementView.extend({
            presentationAttributes: joint.dia.ElementView.addPresentationAttributes({
              tokens: ["TOKENS"],
            }),

            initFlag: joint.dia.ElementView.prototype.initFlag.concat(["TOKENS"]),
           
            //update confirmation
            confirmUpdate: function (...args) {
              let flags = joint.dia.ElementView.prototype.confirmUpdate.call(
                this,
                ...args
              );

              if (this.hasFlag(flags, "TOKENS")) {
                this.renderTokens();
                this.update();
                flags = this.removeFlag(flags, "TOKENS");
              }

              return flags;

            },

            //tokens used for render tokens
            renderTokens: function () {
              const rTokens = this.vel.findOne(".tokens").empty();
              rTokens.addClass("alot");
              var tokens = this.model.get("tokens");
              rTokens.append(joint.V("text").text(`${tokens}`));

            },

          });
      
          joint.shapes.pn.TransitionView = joint.dia.ElementView.extend({
            presentationAttributes: joint.dia.ElementView.addPresentationAttributes({
              enabled: ["ENABLED"],
            }),
         
            //enabled
            initFlag: joint.dia.ElementView.prototype.initFlag.concat(["ENABLED"]),
      
            confirmUpdate: function (...args) {
              let flags = joint.dia.ElementView.prototype.confirmUpdate.call(
                this,
                ...args
              );

              //flags for enabled
              if (this.hasFlag(flags, "ENABLED")) {
                this.renderStatus();
                this.update();
                flags = this.removeFlag(flags, "ENABLED");
              }

              return flags;

            },

            //used render status
            renderStatus: function () {
              let ENABLED_CLASS = "enabled-pulsate";
              let root = this.vel.findOne(".root");
              let label = this.vel.findOne(".label");
              let transitionName = this.model.get("name");
              var enabled = this.model.get("enabled");
              
              if (enabled) {

                //for adding
                label
                  .text(`${transitionName}`)
                  .addClass("enabled")
                  .removeClass("disabled");
                root.addClass(ENABLED_CLASS);
              } else {

                //for removing
                label
                  .text(`${transitionName}`)
                  .removeClass("enabled")
                  .addClass("disabled");
                root.removeClass(ENABLED_CLASS);
              }

            },

          });
      
          var width = this._el.width(),
            height = this._el.height(),
            self = this;
      
          // setting the widget class
          self._el.addClass(WIDGET_CLASS);
          const namespace = joint.shapes;
          self._jointPetriNet = new joint.dia.Graph({}, { cellNamespace: namespace });
          self._jointPaper = new joint.dia.Paper({
            el: self._el,
            width: width, //width
            height: height, //height
            gridSize: 15,
            model: self._jointPetriNet,
            defaultAnchor: { name: "perpendicular" },
            defaultConnectionPoint: { name: "boundary" },
            cellViewNamespace: namespace,
          });
          
        };
      
        PNVisualizerWidget.prototype.onWidgetContainerResize = function (width, height) {
            // resize the widget
          this._logger.debug("Widget is resizing...");
        };
      

        PNVisualizerWidget.prototype.initializePlaceVertices = function () {
          /* create a Circle vertex for each place using Joint JS; create an object
          mapping the joint vertex ids back to the place ids and set
          petriNet.id2place as that object.
          also set each place.joint (petriNet.places[pid1,pid2,...].joint)
          to respective joint vertex
          */
          let self = this;
          self._webgmePetriNet.id2place = {
            /* map on-screen ids to place ids */
          };

          Object.keys(self._webgmePetriNet.places).forEach((placeId) => {
            let place = self._webgmePetriNet.places[placeId];
            let vertex = new joint.shapes.pn.Place({
              position: place.position,
              size: { width: 80, height: 80 },

              attrr: {
                ".label": {
                  text: self._webgmePetriNet.places[placeId].name,
                  fill: "grey",
                },

                ".root": {
                  stroke: "grey",
                  strokeWidth: 1,
                },

                ".tokens > circle": {
                  fill: "black",
                },

              },

              tokens: place.marks,

            });
            self._jointPetriNet.addCell([vertex]);
            self._webgmePetriNet.places[placeId].joint = vertex;
            self._webgmePetriNet.id2place[vertex.id] = placeId;

          });

        };
        
        PNVisualizerWidget.prototype.initializeTransitionVertices = function () {
          /* create a white square vertex for each transition using Joint JS; create an object
          mapping the joint vertex ids back to the transition ids and set
          petriNet.id2transition as that object.
          also set each transition.joint (petriNet.transitions[tid1,tid2,...].joint)
          to respective joint vertex
          */
          let self = this;
          self._webgmePetriNet.id2transition = {
            /* map on-screen ids to place ids */
          };
 
          //defined transition structure
          Object.keys(self._webgmePetriNet.transitions).forEach((transitionId) => {
            let transition = self._webgmePetriNet.transitions[transitionId];
            let vertex = new joint.shapes.pn.Transition({
              name: transition.name,
              position: transition.position,
              size: { width: 60, height: 60 },

              attrr: {
                ".label": {
                  text: transition.name,
                  "text-anchor": "middle",
                  "ref-x": 0.6,
                  "ref-y": -20,
                  ref: ".root",
                  fontSize: 16,
                },

                ".label.enabled": {
                  fill: "blue",
                  stroke: "blue",
                },

                ".label.disabled": {
                  fill: "black",
                  stroke: "black",
                },

                ".root": {
                  fill: "black",
                  stroke: "black",
                },

                ".root.enabled-pulsate": {
                  stroke: "blue",
                  fill: "blue"
                },

              },

            });

            vertex.addTo(self._jointPetriNet);
            self._webgmePetriNet.transitions[transitionId].joint = vertex;
            self._webgmePetriNet.id2transition[vertex.id] = transitionId;
          });

        };
       
        //defined structure for initialize machine
        PNVisualizerWidget.prototype.initMachine = function (petriNetDescriptor) {
            const self = this;
            self._webgmePetriNet = petriNetDescriptor;
            self._jointPetriNet.clear();
            self.initializePlaceVertices();
            self.initializeTransitionVertices();
            ["ArcPlacetotran", "ArcTrantoplace"].forEach((arcType) => {
              self.initializeArcs(arcType);
            });
        
            //refresh the visualization
            self._jointPaper.updateViews();
            self._decorateMachine();
          };


          //structure of arcs
        PNVisualizerWidget.prototype.initializeArcs = function (arcType) {
          let self = this;
          let createJointLink = (a, b, name) => {
            return new joint.shapes.standard.Link({
              source: { id: a.id },
              target: { id: b.id },
              attrs: {

                line: {
                  strokeWidth: 3,
                },

                wrapper: {
                  cursor: "default",
                },
                
              },

              labels: [
                {
                  position: {
                    distance: 0.6,
                    offset: 0,

                    args: {
                      keepGradient: true,
                      ensureLegibility: true,
                    },

                  }

                },

              ],

            });

          };

          let arcsArray =
            arcType === "ArcPlacetotran"
              ? self._webgmePetriNet.arcPlaceToTrans
              : self._webgmePetriNet.arcTransToPlace;
          arcsArray.forEach((arc) => {
            //for source
            let src =
              arcType === "Arcplacetotran"
                ? self._webgmePetriNet.places[arc.src]
                : self._webgmePetriNet.transitions[arc.src];
                //for destination
            let dst =
              arcType === "Arcplacetotran"
                ? self._webgmePetriNet.transitions[arc.dst]
                : self._webgmePetriNet.places[arc.dst];
            src.jointOutArcs = src.jointOutArcs || {};
            let link = createJointLink(src.joint, dst.joint, arc.name);
            link.addTo(self._jointPetriNet);
            src.jointOutArcs[arc.id] = link;
          });

        };
      

        PNVisualizerWidget.prototype.destroyMachine = function () {};
      
        let transitionFireable = (self, t, places_Before = null) => {
          if (!places_Before) {
            var inbound = self._jointPetriNet.getConnectedLinks(t, {
              inbound: true,
            });

            var places_Before = inbound.map(function (link) {
              return link.getSourceElement();
            });

          }

          var Firable = true;
          places_Before.forEach(function (p) {
            if (p.get("tokens") === 0) {
              Firable = false;
            }
          });

          return Firable;
        };
      
        //declaration of running of transitions
        PNVisualizerWidget.prototype.fireEvent = function (transition = null) {
          let self = this;
      
          /* reference: https://github.com/clientIO/joint/blob/master/demo/petri%20nets/src/pn.js#L14 */
      
          let fireTransition = (t, sec, self) => {
            var inbound = self._jointPetriNet.getConnectedLinks(t, { inbound: true });
            var outbound = self._jointPetriNet.getConnectedLinks(t, {
              outbound: true,
            });

            var places_Before = inbound.map(function (link) {
              return link.getSourceElement();
            });
            
            var places_After = outbound.map(function (link) {
              return link.getTargetElement();
            });
      
            // place before transition
            if (transitionFireable(self, t, places_Before)) {
              let TOKEN_COLOR = "#ff0000";
              let TOKEN_RADIUS = 12;
              places_Before.forEach(function (p) {
                // Let the execution finish before adjusting the value of tokens. So that we can loop over all transitions
                // and call fireTransition() on the original number of tokens.
                setTimeout(function () {
                  p.set("tokens", p.get("tokens") - 1);
                }, 0);
      
                var links = inbound.filter(function (l) {
                  return l.getSourceElement() === p;
                });
      
                links.forEach(function (l) {
                  var token = joint.V("circle", {
                    r: TOKEN_RADIUS,
                    fill: TOKEN_COLOR,
                  });

                  l.findView(self._jointPaper).sendToken(token, sec * 100);
                });
                
              });
      
              //place after transition
              places_After.forEach(function (p) {
                var links = outbound.filter(function (l) {
                  return l.getTargetElement() === p;
                });
      
                links.forEach(function (l) {
                  var token = joint.V("circle", {
                    r: TOKEN_RADIUS,
                    fill: TOKEN_COLOR,
                  });

                  l.findView(self._jointPaper).sendToken(
                    token,
                    sec * 100,
                    function () {
                      p.set("tokens", p.get("tokens") + 1);
                    }

                  );

                });

              });

            }

          };

      
          fireTransition(transition.joint, 1, self);
          setTimeout(() => {
            self._decorateMachine();
          }, 1250);

        };

        //transition enabled
        PNVisualizerWidget.prototype.updateUI = function () {
          let self = this;
          let enabledTransitions = [];

          Object.keys(self._webgmePetriNet.transitions).forEach((id) => {
            let transition = self._webgmePetriNet.transitions[id];
            let Fireable = transitionFireable(self, transition.joint);
            transition.joint.set("enabled", Fireable);
            if (Fireable) {
              enabledTransitions.push(transition);
            }

          });

          //transition fire event for deadlock
          self._webgmePetriNet.setFireableEvents(enabledTransitions);
          if (enabledTransitions.length === 0 && !self.hasNotifyDeadLock) {
            self._client.notifyUser({
              message: "Deadlock is reached!",
              severity: "info",
            });

            self.hasNotifyDeadLock = true;
            setTimeout(() => {
              self.hasNotifyDeadLock = false;
            }, 500);

          }

        };
      
        PNVisualizerWidget.prototype.resetMachine = function () {
          this.initMachine(this._webgmePetriNet);
        };
      
        PNVisualizerWidget.prototype._decorateMachine = function () {
          let self = this;
          self.updateUI();

          //checking state machine 
          var StateM= self.checkStateMachine();
          if(StateM){
            self._client.notifyUser({
              message: "State Machine",
              severity: "info",
            });

          }else{
            self._client.notifyUser({
              message: "NOT State Machine",
              severity: "error",
            });

          }

          //checking free choice
          var FreeC= self.checkFreeChoice();
          if(FreeC){
            self._client.notifyUser({
              message: "Free Choice",
              severity: "info",
            });

          }else{
            self._client.notifyUser({
              message: "NOT Free Choice",
              severity: "error",
            });

          }
      
          //checking marking graph
          var MGraph = self.checkMarkingGraph();
          if(MGraph){
            self._client.notifyUser({
              message: "Marking Graph",
              severity: "info",
            });

          }else{
            self._client.notifyUser({
              message: "NOT Marking Graph",
              severity: "error",
            });

          }

        };
      
        // Checking current Net Classification
        PNVisualizerWidget.prototype.checkStateMachine= function (){
          let self = this;   
          return Object.keys(self._webgmePetriNet.transitions).every((transId) => {
            return (
              Object.keys(self._webgmePetriNet.outMatrix).filter(
                (placeId) => self._webgmePetriNet.outMatrix[placeId][transId]
              ).length == 1 &&
              Object.keys(self._webgmePetriNet.inMatrix).filter(
                (placeId) => self._webgmePetriNet.inMatrix[placeId][transId]
              ).length == 1
            );

          });

        };

        //checking marking graph classification
        PNVisualizerWidget.prototype.checkMarkingGraph= function (){
            let self = this;
            return Object.keys(self._webgmePetriNet.places).every((_id) => {
              return (
                Object.keys(self._webgmePetriNet.outMatrix[_id]).filter(
                  (tranId) => self._webgmePetriNet.outMatrix[_id][tranId]
                ).length == 1 &&
                Object.keys(self._webgmePetriNet.inMatrix[_id]).filter(
                  (tranId) => self._webgmePetriNet.inMatrix[_id][tranId]
                ).length == 1
              );
  
            });
  
          };
      
          // for free choice petri net
        PNVisualizerWidget.prototype.checkFreeChoice= function (){
          let map = {};
          let intersection = (ars1, ars2) => {
            return ars1.filter((val) => ars2.includes(val));
          };

          let self = this;
          Object.keys(self._webgmePetriNet.transitions).forEach((tran) => {
            map[tran.id] = Object.keys(self._webgmePetriNet.outMatrix).filter((placeId) => {
              return self._webgmePetriNet.outMatrix[placeId][tran.id];
            });

          });

          let FreeC = Object.keys(map).every((a1, i) => {
            let a1_inplaces = map[a1];
            return Object.keys(map).every((a2, j) => {
              let a2_inplaces = map[t2];
              return intersection(a1_inplaces, a2_inplaces).length == 0 || a1 === a2;
            });
          });
          return FreeC;
        };
      
        


        /* * * * * * * * Visualizer event handlers * * * * * * * */
      
        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        PNVisualizerWidget.prototype.destroy = function () {};
      
        PNVisualizerWidget.prototype.onActivate = function () {
          this._logger.debug("PNVisualizerWidget has been activated");
        };
      
        PNVisualizerWidget.prototype.onDeactivate = function () {
          this._logger.debug("PNVisualizerWidget has been deactivated");
        };
      
        return PNVisualizerWidget;
      });